<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OFD Viewer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5.14.1/dist/reset.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5.14.1/dist/antd.min.css" />
  <style>
    html, body, #root { height: 100%; }
    body { margin: 0; background: #f5f5f5; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Microsoft YaHei", sans-serif; }
    .viewer-layout { min-height: 100%; }
    .viewer-header { background: #fff !important; display: flex; flex-wrap: wrap; align-items: center; gap: 12px; padding: 8px 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.08); position: sticky; top: 0; z-index: 10; }
    .header-controls { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; flex: 1; }
    .file-input { flex: 1; min-width: 220px; }
    .viewer-content { flex: 1; display: flex; flex-direction: column; background: #f0f2f5; }
    .viewer-container { flex: 1; overflow: auto; background: #f0f2f5; }
    .page-wrapper { display: flex; justify-content: center; padding: 24px; }
    .page-frame { background: #fff; box-shadow: 0 6px 18px rgba(0,0,0,0.15); transform-origin: top center; transition: transform 0.2s ease; padding: 16px; }
    .page-frame svg { display: block; }
    .page-placeholder { min-width: 320px; min-height: 420px; display: flex; align-items: center; justify-content: center; }
    .engine-indicator { display: flex; align-items: center; gap: 8px; }
    body.no-select svg text { user-select: none; pointer-events: none; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://cdn.jsdelivr.net/npm/react@18.3.1/umd/react.production.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.3.1/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/antd@5.14.1/dist/antd.min.js" crossorigin="anonymous"></script>
  <script>
    (function () {
      const { useState, useEffect, useCallback, useMemo } = React;
      const { ConfigProvider, Layout, Space, Button, Tooltip, InputNumber, Switch, Typography, Input, Spin, Alert, App: AntdApp, message } = antd;

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function deriveFileName(input) {
        if (!input) return 'file.ofd';
        try {
          const url = new URL(input);
          const pathname = url.pathname;
          const name = pathname.split('/').filter(Boolean).pop();
          if (name) return name;
        } catch (err) {
          /* ignore */
        }
        const parts = input.split('/');
        return parts[parts.length - 1] || 'file.ofd';
      }

      function formatCapabilityTooltip(caps) {
        if (!caps) return '功能信息未知';
        const mark = (value) => value === undefined ? '?' : (value ? '✓' : '✕');
        return [
          `文本: ${mark(caps.text)}`,
          `图形: ${mark(caps.vector)}`,
          `图片: ${mark(caps.images)}`,
          `注释: ${mark(caps.annotations)}`,
          `签章: ${mark(caps.signatures)}`,
        ].join('\n');
      }

      function ViewerApp() {
        const params = useMemo(() => new URLSearchParams(window.location.search), []);
        const initialFile = params.get('file') || 'sample.ofd';

        const [file, setFile] = useState(initialFile);
        const [fileInput, setFileInput] = useState(initialFile);
        const [meta, setMeta] = useState(null);
        const [capabilities, setCapabilities] = useState(null);
        const [engine, setEngine] = useState('');
        const [page, setPage] = useState(1);
        const [pageInput, setPageInput] = useState(1);
        const [zoom, setZoom] = useState(() => {
          const stored = parseFloat(localStorage.getItem('zoom') || '1');
          return Number.isFinite(stored) && stored > 0 ? stored : 1;
        });
        const [textSelectable, setTextSelectable] = useState(() => localStorage.getItem('textSelectable') === '1');
        const [loadingMeta, setLoadingMeta] = useState(false);
        const [loadingPage, setLoadingPage] = useState(false);
        const [error, setError] = useState('');
        const [svgContent, setSvgContent] = useState('');
        const [messageApi, contextHolder] = message.useMessage();

        const metaReady = Boolean(meta);
        const totalPages = meta?.pages ?? 1;

        const updateUrl = useCallback((nextFile) => {
          const url = new URL(window.location.href);
          if (nextFile) {
            url.searchParams.set('file', nextFile);
          } else {
            url.searchParams.delete('file');
          }
          window.history.replaceState({}, '', url.toString());
        }, []);

        useEffect(() => {
          localStorage.setItem('zoom', String(zoom));
        }, [zoom]);

        useEffect(() => {
          if (textSelectable) {
            document.body.classList.remove('no-select');
          } else {
            document.body.classList.add('no-select');
          }
          localStorage.setItem('textSelectable', textSelectable ? '1' : '0');
        }, [textSelectable]);

        const loadMetadata = useCallback(async (targetFile) => {
          setLoadingMeta(true);
          setMeta(null);
          setCapabilities(null);
          setEngine('');
          setSvgContent('');
          setError('');
          try {
            const res = await fetch(`/api/ofd/metadata?file=${encodeURIComponent(targetFile)}`);
            if (!res.ok) {
              throw new Error(await res.text());
            }
            const payload = await res.json();
            setMeta(payload);
            setCapabilities(payload.capabilities || null);
            setEngine(payload.engine || '');
            const total = Math.max(1, payload.pages || 1);
            setPage((prev) => clamp(prev, 1, total));
            setPageInput((prev) => clamp(typeof prev === 'number' ? prev : 1, 1, total));
          } catch (err) {
            const msg = err instanceof Error ? err.message : String(err);
            setError(msg);
            messageApi.error(`加载元数据失败: ${msg}`);
          } finally {
            setLoadingMeta(false);
          }
        }, [messageApi]);

        useEffect(() => {
          setPage(1);
          setPageInput(1);
          updateUrl(file);
          void loadMetadata(file);
        }, [file, loadMetadata, updateUrl]);

        useEffect(() => {
          if (!metaReady) return;
          let aborted = false;
          const controller = new AbortController();
          const fetchPage = async () => {
            setLoadingPage(true);
            setError('');
            try {
              const res = await fetch(`/api/ofd/page?file=${encodeURIComponent(file)}&page=${page}&format=svg`, { signal: controller.signal });
              if (!res.ok) {
                throw new Error(await res.text());
              }
              const svg = await res.text();
              if (!aborted) {
                setSvgContent(svg);
                setError('');
              }
            } catch (err) {
              if (aborted || (err instanceof DOMException && err.name === 'AbortError')) {
                return;
              }
              const msg = err instanceof Error ? err.message : String(err);
              setSvgContent('');
              setError(msg);
              messageApi.error(`渲染失败: ${msg}`);
            } finally {
              if (!aborted) {
                setLoadingPage(false);
              }
            }
          };
          void fetchPage();
          return () => {
            aborted = true;
            controller.abort();
          };
        }, [metaReady, file, page, messageApi]);

        useEffect(() => {
          const handler = (e) => {
            if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
            if (e.key === '+' || (e.key === '=' && e.shiftKey)) {
              setZoom((z) => clamp(z + 0.1, 0.2, 4));
            } else if (e.key === '-') {
              setZoom((z) => clamp(z - 0.1, 0.2, 4));
            } else if (e.key === '0') {
              setZoom(1);
            } else if (e.key === 'ArrowLeft') {
              setPage((p) => clamp(p - 1, 1, totalPages));
            } else if (e.key === 'ArrowRight') {
              setPage((p) => clamp(p + 1, 1, totalPages));
            }
          };
          window.addEventListener('keydown', handler);
          return () => window.removeEventListener('keydown', handler);
        }, [totalPages]);

        const changePage = useCallback((value) => {
          if (!metaReady) return;
          const target = typeof value === 'number' ? value : Number(value);
          if (!Number.isFinite(target)) return;
          const clamped = clamp(target, 1, totalPages);
          setPage(clamped);
          setPageInput(clamped);
        }, [metaReady, totalPages]);

        const handleZoom = useCallback((delta) => {
          setZoom((z) => clamp(z + delta, 0.2, 4));
        }, []);

        const resetZoom = useCallback(() => setZoom(1), []);

        const downloadPage = useCallback((fmt) => {
          const link = document.createElement('a');
          link.href = `/api/ofd/page?file=${encodeURIComponent(file)}&page=${page}&format=${fmt}`;
          link.download = `page-${page}.${fmt}`;
          link.rel = 'noopener noreferrer';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }, [file, page]);

        const downloadOriginal = useCallback(() => {
          const link = document.createElement('a');
          link.href = `/api/ofd/raw?file=${encodeURIComponent(file)}`;
          link.download = deriveFileName(file);
          link.rel = 'noopener noreferrer';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }, [file]);

        const handleFileSubmit = useCallback((value) => {
          const trimmed = (value || '').trim();
          if (!trimmed) {
            messageApi.warning('请输入文件路径或 URL');
            return;
          }
          setFile(trimmed);
          setFileInput(trimmed);
        }, [messageApi]);

        const engineLabel = useMemo(() => {
          if (!engine) return '';
          if (engine === 'ofdrw-cli') return '渲染引擎: OFDRW';
          if (engine === 'basic') return '渲染引擎: 基础';
          return `渲染引擎: ${engine}`;
        }, [engine]);

        const capabilityTooltip = useMemo(() => formatCapabilityTooltip(capabilities), [capabilities]);

        const textToggleDisabled = !meta?.textExtractable || (capabilities && capabilities.text === false);
        const disableNavigation = loadingMeta || loadingPage || !metaReady;

        return React.createElement(ConfigProvider, null,
          React.createElement(AntdApp, null,
            React.createElement(React.Fragment, null,
              contextHolder,
              React.createElement(Layout, { className: 'viewer-layout' },
                React.createElement(Layout.Header, { className: 'viewer-header' },
                  React.createElement('div', { className: 'header-controls' },
                    React.createElement(Space, { align: 'center', wrap: true },
                      React.createElement(Tooltip, { title: '缩小' }, React.createElement(Button, { onClick: () => handleZoom(-0.1), disabled: disableNavigation }, '缩小')),
                      React.createElement(Tooltip, { title: '放大' }, React.createElement(Button, { onClick: () => handleZoom(0.1), disabled: disableNavigation }, '放大')),
                      React.createElement(Button, { onClick: resetZoom, disabled: disableNavigation }, `${Math.round(zoom * 100)}%`),
                      React.createElement(Space, { align: 'center' },
                        React.createElement(Tooltip, { title: '上一页' }, React.createElement(Button, { onClick: () => changePage(page - 1), disabled: disableNavigation || page <= 1 }, '上一页')),
                        React.createElement(Tooltip, { title: '下一页' }, React.createElement(Button, { onClick: () => changePage(page + 1), disabled: disableNavigation || page >= totalPages }, '下一页')),
                        React.createElement('span', null,
                          '第 ',
                          React.createElement(InputNumber, {
                            min: 1,
                            max: totalPages,
                            value: pageInput,
                            size: 'small',
                            disabled: disableNavigation,
                            onChange: (value) => setPageInput(typeof value === 'number' ? value : pageInput),
                            onPressEnter: (e) => changePage(Number(e.target.value)),
                            style: { width: 80, margin: '0 4px' },
                          }),
                          ` / ${totalPages} 页`
                        ),
                        React.createElement(Button, { onClick: () => changePage(pageInput), disabled: disableNavigation }, '前往')
                      )
                    ),
                    React.createElement('div', { className: 'file-input' },
                      React.createElement(Input.Search, {
                        allowClear: true,
                        value: fileInput,
                        placeholder: '输入 OFD 文件路径或 URL',
                        onChange: (e) => setFileInput(e.target.value),
                        onSearch: handleFileSubmit,
                        enterButton: '加载',
                        disabled: loadingMeta,
                      })
                    ),
                    React.createElement(Space, { align: 'center', size: 'middle' },
                      React.createElement(Tooltip, { title: textToggleDisabled ? '此文件不支持文本选择' : '切换文本选择模式' },
                        React.createElement(Switch, {
                          checked: textSelectable,
                          disabled: textToggleDisabled,
                          onChange: (checked) => setTextSelectable(checked),
                          checkedChildren: '文本',
                          unCheckedChildren: '文本',
                        })
                      ),
                      React.createElement(Button, { onClick: () => downloadPage('png'), disabled: !svgContent || loadingPage }, '下载 PNG'),
                      React.createElement(Button, { onClick: () => downloadPage('pdf'), disabled: !svgContent || loadingPage }, '下载 PDF'),
                      React.createElement(Button, { onClick: downloadOriginal, disabled: loadingMeta }, '下载 OFD')
                    ),
                    engineLabel ? React.createElement(Tooltip, { title: capabilityTooltip },
                      React.createElement(Typography.Text, { type: 'secondary', className: 'engine-indicator' }, engineLabel)
                    ) : null
                  )
                ),
                React.createElement(Layout.Content, { className: 'viewer-content' },
                  React.createElement('div', { className: 'viewer-container' },
                    React.createElement('div', { className: 'page-wrapper' },
                      React.createElement('div', { className: 'page-frame', style: { transform: `scale(${zoom})` } },
                        loadingMeta ? React.createElement('div', { className: 'page-placeholder' }, React.createElement(Spin, { tip: '加载元数据...' })) :
                          loadingPage ? React.createElement('div', { className: 'page-placeholder' }, React.createElement(Spin, { tip: '渲染中...' })) :
                            error ? React.createElement(Alert, { type: 'error', message: '渲染失败', description: error, showIcon: true }) :
                              svgContent ? React.createElement('div', { dangerouslySetInnerHTML: { __html: svgContent } }) :
                                React.createElement('div', { className: 'page-placeholder' }, React.createElement(Typography.Text, { type: 'secondary' }, '暂无内容'))
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }

      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(React.createElement(ViewerApp));
    })();
  </script>
</body>
</html>
